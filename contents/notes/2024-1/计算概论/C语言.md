# 基础概念
- 程序设计语言：编写计算机程序所用的语言，分为机器语言、汇编语言、高级语言
- 编译的角度，有两类程序设计语言
	- 编译型
	- 解释型
# 数据类型、运算符与表达式
- 常量与变量
	- 常量：在程序运行过程中，其值一直保持不变的量为常量
	- 变量：在程序运行过程中，其值可以改变的量为变量
- 整型数据：
	- 整型常量，范围 $-2^{31}\sim (2^{31}-1)$
	- 整型变量
		- 有符号型：
			- Short，2 个字节，$-2^{15}\sim(2^{15} -1)$
			- Int，4 个字节，$-2^{31}\sim(2^{31} -1)$
			- Long，4 个字节，$-2^{31}\sim(2^{31} -1)$
		- 无符号型：
			- Unsigned Short，2 个字节，$0\sim(2^{16} -1)$
			- Unsigned Int，4 个字节，$0\sim(2^{32} -1)$
			- Unsigned Long，4 个字节，$0\sim(2^{32} -1)$
		- 不同类型的整型数据间的赋值归根到底就是一条：按存储单元中的存储形式直接传送。
- 浮点数
	- Float：四个字节，7～8 位有效数字
	- Double：八个字节，15～16 位有效数字
	- 当计算机中出现小于机器所能表示的最小数时只能当零来处理；出现超过机器所能表示的最大数时会溢出，一旦溢出就会停止运算
- 字符型数据（char）
	- 实际上作为整型数据在内存中存储的
	- 可以直接用整型值给变量赋值
	- 有些ASCII的字符代表某些操作，不能打印出来，如回车、退格等，可用两种方式表示这些字符。
		- 用ASCII码的形式          char   re=13;
		- 用转义字符               char   re=‘\n’;
	- 字符串常量：用" "表示，在内存中顺序存放，以'\0'结束
- 算术运算符和算术表达式
	- 两个整数相除结果为整数
	- 整数才可求余，余数的符号与左边数相同
- 自增、自减运算符
	- ++在前，先运算，后赋值
	- ++在后，先赋值，后运算
- 运算优先级
	- 关系运算符：<, <=, >, >= 级别一致，优先于\==, !=
	- 关系运算符低于算术运算符
	- 关系运算符高于赋值运算符
- 逗号运算符：顺序求解，结果为最后一个表达式的值，且优先级最低
- 位运算符：
	- 按位与 &
	- 按位或 |
	- 按位异或 ^
	- 取反运算符 ~
	- 左移运算符 <<
	- 右移运算符 >>
# 简单的输入输出
- C 风格的输入输出 
	- scanf ("<格式化字符串>"\[,<地址表>\]);
	- 控制串由三类字符构成：格式化说明符，空白符号，非空白符
	- Printf ("<格式化字符串>"\[,<参量表>\])
	- 双精度实数是 lf，单精度是 f，科学计数法用 e
	- Flag 规定输出样式，-左对齐，+右对齐，0 在前面补零，空格正值为空格，负值为负号
	- Width 可以使用\*和参数动态指定
- C++风格的输入输出
	- 字符型变量过滤空白字符，cin 格式过滤空白字符
	- 若要把空格和回车键作为输入赋值给字符，必须使用 `cin.get()`
	- `cin>> hex>>i`
	- `cout << setw(5) << i` 设置输出项宽度
# 流程控制语句
- 程序的三种基本结构：顺序，选择，循环
- 条件运算符：c++中唯一的三目运算符，优先级比赋值运算高，结合方向自右至左，运算求解从左至右
- Switch 语句
	- 仅能判断一种逻辑关系，即是否等于制定的常量
	- Case 子句后必须为常量，通常是整型和字符型
	- Default 可以省略，此时什么也不执行
- Do while 循环语句：至少执行一次循环体
# 函数
- C 程序的执行从 main 开始，其他函数不能调用 main 函数
- 在未出现函数调用时，形参不占内存的存储单元；只要函数开始调用时，形参才被分配内存单元
- 函数的类型决定返回值的类型
- 如果函数中出现了自增减符号，在调用之前完成
- 对函数必须先声明再调用
- 函数可以嵌套调用，不可以嵌套定义
- 在调用一个函数的过程中直接或间接地调用函数本身，称为函数的递归调用。
- 局部变量和全局变量：
	- 局部变量：在一个函数内部定义的变量是局部变量，只有在函数内部才能使用该变量
	- 不同函数内可以定义名字相同的变量
	- 形式参数也是局部变量
	- 全局变量：函数外部定义的变量称为全局变量，可以为本文件的其他函数使用
	- 局部变量和全局变量同名：局部优先
- 动态和静态存储类
	- 所有的变量有数据类型和存储类别两个属性,后者分为静态的和动态的两种，缺省为动态类型（auto）。由关键词static声明的静态变量在函数调用后只会初始化一次，其数值保留。
- 文件包含：
	-  `<header.h>`：优先在系统或编译器的标准库路径中查找。用于标准库头文件，如 `<stdio.h>`、`<stdlib.h>` 等。
    - `"header.h"`：优先在当前文件所在目录中查找，如果找不到，再去标准库路径查找。用于用户自定义的头文件或项目特定的头文件。
- 宏定义
	- 不带参数宏定义的写法：
		- ` #define 标识符字符串`
		- **宏定义注意的问题**：宏定义只是简单的文本替换，不会进行类型检查或计算。
	- 带参数宏定义的写法：
	- `#define 宏名(参数表) 字符串`
	- `#define Area(a, b) a * b`
	- **带参数的宏定义使用时注意的问题**：
	- 1. **展开时不自动加括号**：宏定义只是简单的文本替换，不会自动添加括号，可能导致意外的行为。
	- 2. **只是代替**：宏定义不会进行类型检查或计算，使用时需要特别小心。
# 数组
- 定义方法 `类型说明符 数组名[常量表达式];`
	- 其中常量表达式必须是常数
	- 数组大小不能是变量
	- 如果要根据不同的数值改变数组大小，可用常量表达式
- 初始化：对于一部分元素列举初值
	- 未赋值的部分是 0，不能整体赋值，只能一个个的赋值
	- 可以用缺省长度赋值，会自动计算元素项数
	- 局部 static 或者全局定义的数组不赋初值，系统默认为 `'\0'`
- 数组在内存中顺序存放，第一个元素位于地址的最低端
- 排序算法
	- 冒泡排序：相邻的两个数两两比较
	- 选择排序：每次选择最小数
- 二维数组的定义
	- 定义方法：`类型说明符 数组名[常量表达式][常量表达式];`
	- 即在内存中，多维数组依然是直线顺序排列的，第一个元素位于最低地址处。
	- 初始化可以分行赋值，也可以顺序赋值，还可以部分赋值
	- 分行赋值或者全部赋值时，可以省略第一维的长度，第二维不可以省
	- 局部 static 或者全局定义的数组不赋初值，系统默认为 `'\0'`
- 数组作为函数参数
	- 数组元素作函数实参，用法与一般变量作实参相同，是“值传递”。
	- 数组名作为函数参数，实参中的数组地址传到形参中，实参形参共用同一段内存。
		- 需指定实参数组大小，形参数组的大小可不指定。数组名作实参实际上是传递数组的首地址。
		- 需指定实参数组大小，形参数组的大小可不指定。数组名作实参实际上是传递数组的首地址。
	- 如果实参、形参是二维数组，则形参可以省略第一维，不可省略第二维，且第二维必须与实参中的维数相等。
- 字符数组
	- 用来存放字符数据的数组是字符数组，字符数组中的一个元素存放一个字符。
	- 定义 `char 数组名[常量表达式]`
	- 如果字符个数大于数组长度，做错误处理；如果数值个数小于数组长度，后面的字节全部为 `'\0'`
- 字符串和字符串结束标志
	- C++语言中约定用 `'\0'` 作为字符串的结束标志，它占内存空间，但不计入串长度。
	- 在语句中字符数组不能用赋值语句整体赋值 （只可以赋初值）
	- 把字符数组作为字符串输入输出。对于一维字符数组的输入，在cin中仅给出数组名；输出时，在cout中也只给出数组名。cin只能输入一个单词，不能输入一行单词。
	- 当要把输入的一行作为一个字符串送到字符数组中时，则要使用函数cin.getline( )
- 字符串处理函数
	- 所有字符串处理函数的实参都是字符数组名
	- 合并两个字符串的函数  strcat (str1, str2)
	- 复制两个字符串的函数  strcpy (str1, str2)
	- 比较两个字符串的函数  strcmp (str1, str2)
	- 求字符串长度的函数  strlen (str1)
# 结构体、共同体和枚举类型
- 结构体
	- `struct 结构体名 {成员列表};`
	- 结构体类型只是一种数据类型，不占内存空间，只有定义结构体类型变量时才开辟内存空间
	- 在定义类型的同时定义变量
		- `struct 结构体名 {成员列表｝变量名列表；`
	- 直接定义结构体类型变量
		- `struct {成员列表｝变量名列表；`
	- 结构体类型的变量在内存依照其成员的顺序顺序排列，所占内存空间的大小是其全体成员所占空间的总和。
	- 结构体的成员可以是另一个结构体类型
	- 成员名可以与程序中的变量名相同，二者分占不同的内存单元，互不干扰。
	- 可以将一个结构体变量整体赋给另外一个相同类型的结构体变量
	- 结构体变量可以作为函数的参数，函数也可以返回结构体的值。当函数的形参与实参为结构体类型的变量时，这种结合方式属于值调用方式，即属于值传递
- 共同体
	- C++语言中，允许不同的数据类型使用同一存储区域，即同一存储区域由不同类型的变量共同表示。这种数据类型就是共用体。
	- `union 共用体名 {  成员表列;} 变量表列;`
	- 这几个成员在共用体变量中存放在同一地址，相互覆盖，其长度为最长的成员的长度。
	- 不能整体引用共用体变量，只能引用变量中的成员。
- 枚举类型
	- 如果一个变量只有几种可能的值，可以定义为枚举类型。
	- `enum  weekday  {sun, mon, tue, wed, thu,  fri,  sat};`
	- 枚举元素为常量，不可赋值运算。  sun=0;  mon=1;
	- 在定义枚举类型的同时，编译程序按顺序给每个枚举元素一个对应的序号，序号从0开始，后续元素依次加1
	- 可以在定义时人为指定枚举元素的序号值
	- 枚举元素可以用来进行比较判断
	- 枚举值可以进行加减一个整数n的运算，得到其前后第n个元素的值。
# 指针
- 一个变量的地址称为该变量的指针
- 可以定义一个变量专门用来存放另一变量的地址，这种变量我们称之为指针变量。
- `类型标识符 *变量名`
- 一个指针变量只能始终指向同一类型变量
-   * 在语句中表示“指向”。&表示“取地址”。
- 定义时\*表示类型，语句中\*表示指向的单元
- 绝对不能对未赋值的指针变量作“指向”运算。
- ++, - -,  * 优先级相同，都是右结合性。
- 函数
	- 指针变量作为函数参数与变量本身作函数参数不同，变量作函数参数传递的是具体值，而指针作函数参数传递的是内存的地址。
	- 函数调用不能改变实参指针变量的值，但可以改变实参指针变量所指向变量的值。
	- 用数组名作形参，因为接收的是地址，所以可以不指定具体的元素个数。
- 数组
	- C++规定：数组名就是数组的起始地址；数组的指针就是数组的起始地址。
	- C++规定，p+1指向数组的下一个元素，而不是下一个字节。
	- 对于数组 `int a[10], *p;` 两种赋值 `p = &a[0];` 和 `p=a;` 的效果相同，不过在后一种赋值中，p 是变量，a 是常量
- 字符串的指针
	- 用字符指针表示字符串 `char *string = "I love China";`
	- 字符数组和字符指针变量都可以实现字符串的存储和运算，区别在于：
		- 字符数组名是常量，定义时必须指明占用的空间大小。
		- 字符指针变量是变量，里面存储的是字符型地址，若指向字符串，该字符串必须以‘\0’结尾。
- 函数的指针
	- 可以用指针变量指向变量、字符串、数组，也可以指向一个函数；函数在编译时被分配给一个入口地址。这个入口地址就称为函数的地址，也是函数的指针。`函数类型 (*指针变量名)(参数类型 );
	- `int (*p)( int, int);` 同时该函数具有两个整型形参，且该函数的返回值为整型数
- 返回指针值的函数
	- `类型标识符     *函数名(参数表)`
- 在内存动态分配存储空间
	- 利用 new 运算符可以在程序中动态开辟内存空间
	- `new   数据类型[单位数];`
	- 同样，利用new运算符也可以开辟连续的多个空间(数组)![[动态数组.png]]
	- 用new开辟的内存单元没有名字，指向其首地址的指针是引用其的唯一途径，若指针变量重新赋值，则用new开辟的内存单元就在内存中“丢失”了，别的程序也不能占用这段单元，直到重新开机为止。
	- delete运算符用来将动态分配到的内存空间归还给系统，使用格式为：`delete  p;`
	- delete也可以收回用new开辟的连续的空间。`delete []point;`
# 文件操作
- 文件的概念
	- 普通的磁盘文件
	- 输入输出设备
- 文本文件和二进制文件
- C 语言中处理文件的方式
	- 字节流, 可以编写程序读取文件中的每一个字节
- C 中对文件操作---以函数的方式实现
*  缓冲文件系统和非缓冲文件系统
* 文件指针：在C语言中，每打开一个文件就开辟一块内存，保存打开文件的基本信息，这些信息由一个结构定义，类型为 FILE，在 stdio.h 文件中定义了该结构
* 文件操作
	* 打开：`fopen(char * filename, char * openmode);`![[打开模式.png]]
	* 关闭：`fclose(FILE *fp);`
	* 读写：![[读写.png]]
	* 文件定位：
		*  Rewind 函数
			- 函数原型：`void rewind(FILE *fp);`
			- 参数：`fp` 是指向文件的指针。
			- 功能：将文件指针重置到文件的开头，相当于调用 `fseek(fp, 0, SEEK_SET)`，同时清除文件结束标志和错误标志。
			- 示例：
			  ```c
			  FILE *fp = fopen("example.txt", "r");
			  rewind(fp); // 将文件指针重置到文件开头
			  ```
		-  Fseek 函数
			- 函数原型：`int fseek(FILE *fp, long offset, int whence);`
			- 参数：
			  - `fp` 是指向文件的指针。
			  - `offset` 是偏移量，表示从 `whence` 指定的位置移动的字节数。
			  - `whence` 是起始位置，可以是以下值之一：
			    - `SEEK_SET`：从文件开头开始计算。
			    - `SEEK_CUR`：从当前位置开始计算。
			    - `SEEK_END`：从文件末尾开始计算。
			- 返回值：成功时返回 `0`，失败时返回非零值。
			- 功能：将文件指针 `fp` 移动到 `whence` 指定的位置加上 `offset` 的位置。
			- 示例：
			  ```c
			  FILE *fp = fopen("example.txt", "r");
			  fseek(fp, 10, SEEK_SET); // 将文件指针移动到文件开头后的第 10 个字节
			  ```
		 - Ftell 函数
			- 函数原型：`long ftell(FILE *fp);`
			- 参数：`fp` 是指向文件的指针。
			- 返回值：返回文件指针的当前位置（相对于文件开头的字节数），如果发生错误，返回 `-1L`。
			- 功能：返回文件指针 `fp` 的当前位置，通常用于记录文件指针的位置或计算文件大小。
			- 示例：
			  ```c
			  FILE *fp = fopen("example.txt", "r");
			  fseek(fp, 0, SEEK_END); // 将文件指针移动到文件末尾
			  long size = ftell(fp);  // 获取文件大小
			  printf("File size: %ld bytes\n", size);
			  ```
