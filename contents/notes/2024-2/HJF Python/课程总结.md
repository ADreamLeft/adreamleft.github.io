  

# HJF你是真司马啊
## 1 **课程基本信息**  
- **课程名称**：PYTHON程序设计与数据科学导论  
- **总结主题**：课程内容回顾与总结  
- **所属学院**：北京大学计算机学院  
- **总结人**：胡俊峰  


## 2 **课程内容概述**  
1. **核心模块**  
   - Python编程技术  
   - 数据科学基础原理与技术  
   - 机器学习原理与实践  
   - 图像处理、时间序列分析基础  
   - 神经网络与深度学习基础  

2. **Python语言部分**  
   - **重点内容**（★★★）：  
     - 容器-迭代器、生成器  
     - 函数、匿名函数与列表生成式、函数式编程  
     - 类定义-实例化、可执行类、迭代器类  
     - 协程、异步编程实现  
	     - <font color="#ff0000">协程的内容</font>：
		     - 本质上是一个可被异步唤醒的函数
		     - 存在自阻塞操作（语句）的被动服务函数
		     - 存在发出调用操作并等待调用返回才继续执行的主动客户方
		     - 协程的调度由用户程序（而非系统内核）自己来控制
		 - <font color="#ff0000">协程的概念和实现方法</font>：
			 - 协程（coroutine）是一种用户态的轻量级线程，用于实现非阻塞并发编程。  它通过 挂起（suspend）与恢复（resume）机制，在执行过程中可以主动让出控制权，实现多个任务之间的高效切换。
			 - 基于生成器的协程（generator-based coroutine）
				 - 使用 `yield` 或 `yield from` 来实现协程行为
			 - **基于 async/await 的协程（现代协程）**
				 - 使用 `async def` 定义协程函数，内部用 `await` 挂起
		- <font color="#ff0000">协程的特点</font>
			- 每个协程并没有单独的 Python 解释器实例执行指令。协程是 在同一个 Python 解释器实例中执行的，它们共享相同的解释器环境。
			- 协程在处理 I/O 通讯、资源管理和操作响应等方面非常有用。 由于协程可以暂停和恢复执行，可以轻松地在 I/O 操作等待期间切换到其他协程，从 而提高程序的效率。协程也可以用于异步编程模型，使得处理并发任务更加简单和高 效。
   - **次重点内容**（★★）：  
     - 类继承、装饰器类、设计模式简介  
   - **基础内容**（★）：  
     - 进程、线程  
     - TCP/IP Socket，网络编程概述  

3. **NumPy与线性代数**  
   - **重点内容**（★★★）：  
     - 矩阵基本操作（定义、计算、维度变换、矩阵切片） 
     - 矩阵特征值、特征向量；矩阵分解  
     - 矩阵运算、广播机制、向量运算  

4. **基于矩阵计算的数据科学原理与技术**  
   - **重点内容**（★★★）：  
     - 矩阵计算及相关物理意义  
     - 矩阵分解与特征降维、降噪、协同过滤  
	     - <font color="#ff0000">可以使得结果变得稀疏的方法</font>
		     - L1 正则化
     - 向量空间-距离-聚类  
	     - Kmeans 聚类的内容
		     - 非监督学习
		     - 与初始中心的选择有关
		     - 可以使用不同的距离函数和核函数

5. **Pandas数据处理**  
   - **重点内容**（★★★）：  
     - 表数据处理基础、apply函数使用、缺失数据处理  
     - 聚合操作与统计分析、表连接-融合
   - **次重点内容**（★）：  
     - 高维表处理  

6. **Python与机器学习**  
   - **重点内容**（★★★）：  
     - 贝叶斯分类器
     - 线性回归、logistic regression  
     - K-means、KNN  
   - **次重点内容**（★★）：  
     - 图分析与SNA基础  
     - 基于关联的推荐模型，HITS算法  

7. **图像处理、时间序列分析基础**  
   - **重点内容**（★★）：  
     - 图像编码与基本概念  
     - 图像特征与图像建模  
     - 时间序列处理基础（趋势-周期平稳化）  
	     - 将非平稳时间序列转换为平稳序列的方法：
		     - 差分、回归
   - **次重点内容**（★）：  
     - DCT与图像压缩  
	     - <font color="#ff0000">DCT 与图像压缩的基本内容</font>
		     - 图像的DCT变换与压缩编码
			     - 频域变换、降低高频分量的分辨度、降阶编码-压缩
			     - 量化 Quantization：$Q(x, \delta)=[\frac{x+0.5}{\delta}]$
			     - 量化表（DCT 系数矩阵）：左上角是低频信号，右下角是高频信号
			     - 二维 DCT 相当于对列和行依次做了一次一维 DCT
     - 序列回归、平滑滤波  
     - 序列特征挖掘与预测  

8. **神经网络与深度学习基础**  
   - **重点**（★★★）
	   -    神经网络原理与模型实现（python + numpy）  
   - **重点内容**（★★）：  
     - CNN、RNN-LSTM  
	     - <font color="#ff0000">LSTM+attention机制实现的序列生成模型（seq2seq），在实际使用中在输出序列中会容易生成一些重复的单词。请简要分析这种现象的原因（2分），给出你认为合理的解决问题方案（2分）</font>
		     - 在 LSTM + Attention 的 Seq2Seq 生成任务中，**输出中生成重复单词的原因**主要包括：
				- **注意力机制聚焦不够分散**：注意力可能长期集中在输入序列中的某几个位置，导致 Decoder 反复关注同样的内容；
				- **缺乏全局生成状态控制**：Decoder 在生成过程中缺乏对“已经生成了哪些词”的显式记忆，无法避免重复；
				- **训练时目标函数没有对重复进行惩罚**：通常只优化词级别的交叉熵损失，忽视了句子级别的结构质量；
				- **语言模型偏移**：Decoder 的语言模型倾向于生成高频词或习惯搭配，容易“卡壳”在某些词上。
			- 解决方案：
				- 覆盖机制：用一个**覆盖向量**记录历史上注意力已经关注过的内容；在新的注意力计算中加入“重复惩罚项”，减少注意力集中在相同输入位置的概率。
				- 加入重复惩罚的损失函数：修改训练损失，在生成重复词时引入惩罚，例如引入**重复惩罚损失**（repetition penalty）；或者在 beam search 解码阶段加惩罚项。
		- <font color="#ff0000">Beam Search 的简单流程</font>
			1. 初始化：
			    - 将解码器的初始输入（如起始符 `<sos>`）放入候选序列列表中。
			    - 设置 beam size 为 B。
			2. 第一步解码：
			    - 对每个候选序列（初始只有一个）进行一次解码，得到下一个词的概率分布。
			    - 选择概率最高的前 B 个词，形成 B 个新的序列，并记录它们的累计得分。
			3. 后续步骤：
			    - 对当前的 B 个候选序列，每个继续解码一步，得到各自的下一个词的概率分布。
			    - 每个序列会扩展成 V（词表大小）个新序列，总共有 B × V 个新序列。
			    - 从这 B × V 个序列中选择得分最高的前 B 个，作为新的候选序列。
			4. 重复解码：不断重复上一步，直到：
				- 达到最大生成长度，或
				- 所有候选序列都生成了终止符 `<eos>`。
			5. 输出：
			    - 从最终的候选序列中选得分最高的一个作为最终输出，或者保留多个候选序列用于后处理。
   - **次重点内容**（★）：  
     - Transformer建模与预训练模型基础  
     - 图像生成模型基础  
     - 深度学习架构方案与实现  
     - Pytorch张量计算，梯度回传机制  

## 3 **笔试内容分布**  
- Python语言技术（30-35%）  
- Numpy、pandas及特征分析、数据分析（20-25%）  
- CV、TSA、图分析（15%-20%）  
- 机器学习概念与方法（10-15%）  
- 神经网络、深度学习及建模（15-20%）  

## 4 代码结果预测题
```
def main():
	try:	
		func()	
		print("function ends")		
	except ZeroDivisionError:
		print('Divided By Zero! ')
	except:
		print('Its an Exception!') 

def func():
	print(1/0)

main()
```
其实会输出 zero 的错误，因为python 在执行之前函数就可以调用另外一个还未声明的函数